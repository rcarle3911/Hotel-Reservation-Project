"use strict";
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
/// <reference path="../typings/main.d.ts" />
var ts = require("./typesystem");
var su = require("./schemaUtil");
var _ = require("underscore");
var typesystem_1 = require("./typesystem");
var typesystem_2 = require("./typesystem");
/**
 * this class is an abstract super type for every constraint that can select properties from objects
 */
var MatchesProperty = (function (_super) {
    __extends(MatchesProperty, _super);
    function MatchesProperty(_type) {
        _super.call(this);
        this._type = _type;
    }
    MatchesProperty.prototype.matches = function (s) {
        return false;
    };
    MatchesProperty.prototype.check = function (i, p) {
        throw new Error("Should be never called");
    };
    MatchesProperty.prototype.patchPath = function (p) {
        if (!p) {
            return { name: this.propId() };
        }
        else {
            var c = p;
            var r = null;
            var cp = null;
            while (c) {
                if (!r) {
                    r = { name: c.name };
                    cp = r;
                }
                else {
                    var news = { name: c.name };
                    cp.child = news;
                    c = c.child;
                    cp = news;
                }
            }
            r.child = { name: this.propId() };
            return r;
        }
    };
    MatchesProperty.prototype.validateProp = function (i, n, t, q) {
        var vl = i[n];
        var st = t.validate(vl, false, false);
        if (!st.isOk()) {
            if (t.isUnknown() || t.isRecurrent()) {
                var s = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Validating instance against unknown type: '" + t.name() + "'", this);
                s.setValidationPath(this.patchPath(q));
                return s;
            }
            var s = new typesystem_2.Status(typesystem_2.Status.OK, 0, "", this);
            st.getErrors().forEach(function (x) { return s.addSubStatus(x); });
            s.setValidationPath(this.patchPath(q));
            return s;
        }
        return ts.ok();
    };
    MatchesProperty.prototype.validateSelf = function (registry) {
        if (this._type.isExternal()) {
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in property definitions", this);
            p.setValidationPath({ name: this.propId() });
            return p;
        }
        if (this._type.isSubTypeOf(ts.UNKNOWN) || this._type.isSubTypeOf(ts.RECURRENT)) {
            var actualUnknown = actualUnknownType(this._type);
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Property '" + this.propId() + "' refers to unknown type '" + actualUnknown.name() + "'", this);
            p.setValidationPath({ name: this.propId(), child: { name: "type" } });
            return p;
        }
        if (this._type.isAnonymous()) {
            var st = this._type.validateType(registry);
            if (!st.isOk()) {
                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, ("Property '" + this.propId() + "' range type has error: ") + st.getMessage(), this);
                st.getErrors().forEach(function (y) { p.addSubStatus(y); });
                p.setValidationPath({ name: this.propId() });
                return p;
            }
            return st;
        }
        if (this._type.isUnion()) {
            var ui = _.find(this._type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
            if (ui) {
                var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, ("Property '" + this.propId() + "' refers to unknown type ") + ui.name(), this);
                p.setValidationPath({ name: this.propId() });
                return p;
            }
        }
        return ts.ok();
    };
    return MatchesProperty;
}(ts.Constraint));
exports.MatchesProperty = MatchesProperty;
var MatchToSchema = (function (_super) {
    __extends(MatchToSchema, _super);
    function MatchToSchema(_value, provider) {
        _super.call(this);
        this._value = _value;
        this.provider = provider;
    }
    MatchToSchema.prototype.value = function () {
        return this._value;
    };
    MatchToSchema.prototype.check = function (i) {
        var so = null;
        var strVal = this.value();
        if (strVal.charAt(0) == "{") {
            try {
                so = su.getJSONSchema(strVal, this.provider);
            }
            catch (e) {
                return new ts.Status(ts.Status.ERROR, 0, "Incorrect schema: " + e.message, this);
            }
        }
        if (strVal.charAt(0) == "<") {
            try {
                so = su.getXMLSchema(strVal, this.provider);
            }
            catch (e) {
                return ts.ok();
            }
        }
        if (so) {
            try {
                so.validateObject(i);
            }
            catch (e) {
                if (e.message == "!_PERF_!") {
                    return new ts.Status(ts.Status.WARNING, 0, "Unable to validate example against schema (xmllint)", this);
                }
                if (e.message == "Cannot assign to read only property '__$validated' of object") {
                    return ts.ok();
                }
                if (e.message == "Object.keys called on non-object") {
                    return ts.ok();
                }
                if (e.message == "Maximum call stack size exceeded") {
                    return new ts.Status(ts.Status.ERROR, 0, "JSON schema contains circular references", this);
                }
                return new ts.Status(ts.Status.ERROR, 0, "Example does not conform to schema: " + e.message, this);
            }
        }
        return ts.ok();
    };
    MatchToSchema.prototype.facetName = function () {
        return "schema";
    };
    MatchToSchema.prototype.requiredType = function () {
        return ts.EXTERNAL;
    };
    return MatchToSchema;
}(ts.Constraint));
exports.MatchToSchema = MatchToSchema;
/**
 * this is a constraint which checks that object has no unknown properties if at has not additional properties
 */
var KnownPropertyRestriction = (function (_super) {
    __extends(KnownPropertyRestriction, _super);
    function KnownPropertyRestriction(_value) {
        _super.call(this);
        this._value = _value;
    }
    KnownPropertyRestriction.prototype.facetName = function () {
        return "closed";
    };
    KnownPropertyRestriction.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    KnownPropertyRestriction.prototype.value = function () {
        return this._value;
    };
    KnownPropertyRestriction.prototype.patchOwner = function (t) {
        this._owner = t;
    };
    KnownPropertyRestriction.prototype.check = function (i) {
        var _this = this;
        if (this._value === false) {
            if (i && typeof i == 'object' && !Array.isArray(i)) {
                var nm = {};
                Object.getOwnPropertyNames(i).forEach(function (n) { return nm[n] = true; });
                var mp = this.owner().knownProperties();
                Object.getOwnPropertyNames(i).forEach(function (p) {
                    mp.forEach(function (v) {
                        if (v.matches(p)) {
                            delete nm[p];
                        }
                    });
                });
                var unknownPropertyNames = Object.keys(nm);
                if ((this.owner().hasPropertiesFacet() || mp.length > 0) && unknownPropertyNames.length > 0) {
                    var s = new ts.Status(ts.Status.OK, 0, "", this);
                    unknownPropertyNames.forEach(function (x) {
                        var err = ts.error("Unknown property: '" + x + "'", _this);
                        err.setValidationPath({ name: x });
                        s.addSubStatus(err);
                    });
                    return s;
                }
            }
        }
        return ts.ok();
    };
    KnownPropertyRestriction.prototype.composeWith = function (restriction) {
        if (!this._value) {
            return null;
        }
        if (restriction instanceof KnownPropertyRestriction) {
            var mm = restriction;
            if (_.isEqual(this.owner().propertySet(), mm.owner().propertySet())) {
                return mm;
            }
        }
        if (restriction instanceof HasProperty) {
            var ps = restriction;
            var name = ps.value();
            var allowedPropertySet = this.owner().propertySet();
            if (allowedPropertySet.indexOf(name) == -1) {
                return this.nothing(ps);
            }
        }
    };
    return KnownPropertyRestriction;
}(ts.Constraint));
exports.KnownPropertyRestriction = KnownPropertyRestriction;
/**
 * this constaint checks that object has a particular property
 */
var HasProperty = (function (_super) {
    __extends(HasProperty, _super);
    function HasProperty(name) {
        _super.call(this);
        this.name = name;
    }
    HasProperty.prototype.check = function (i) {
        if (i && typeof i == 'object' && !Array.isArray(i)) {
            if (i.hasOwnProperty(this.name)) {
                return ts.ok();
            }
            return ts.error("Required property '" + this.name + "' is missing", this);
        }
        return ts.ok();
    };
    HasProperty.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    HasProperty.prototype.facetName = function () {
        return "hasProperty";
    };
    HasProperty.prototype.value = function () {
        return this.name;
    };
    HasProperty.prototype.composeWith = function (r) {
        if (r instanceof HasProperty) {
            var hp = r;
            if (hp.name === this.name) {
                return this;
            }
        }
        return null;
    };
    return HasProperty;
}(ts.Constraint));
exports.HasProperty = HasProperty;
/**
 * this constraint checks that property has a particular tyoe if exists
 */
var PropertyIs = (function (_super) {
    __extends(PropertyIs, _super);
    function PropertyIs(name, type, optional) {
        if (optional === void 0) { optional = false; }
        _super.call(this, type);
        this.name = name;
        this.type = type;
        this.optional = optional;
    }
    PropertyIs.prototype.matches = function (s) {
        return s === this.name;
    };
    PropertyIs.prototype.path = function () {
        return this.name;
    };
    PropertyIs.prototype.check = function (i, p) {
        if (i && typeof i === "object") {
            if (i.hasOwnProperty(this.name)) {
                var st = this.validateProp(i, this.name, this.type, p);
                if (!st.isOk() && this.optional && i[this.name] == null) {
                    return ts.ok();
                }
                return st;
            }
        }
        return ts.ok();
    };
    PropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    PropertyIs.prototype.propId = function () {
        return this.name;
    };
    PropertyIs.prototype.propertyName = function () {
        return this.name;
    };
    PropertyIs.prototype.facetName = function () {
        return "propertyIs";
    };
    PropertyIs.prototype.value = function () {
        return this.type;
    };
    PropertyIs.prototype.composeWith = function (t) {
        if (t instanceof PropertyIs) {
            var pi = t;
            if (pi.name === this.name) {
                if (this.type.typeFamily().indexOf(pi.type) != -1) {
                    return pi;
                }
                if (pi.type.typeFamily().indexOf(this.type) != -1) {
                    return this;
                }
                setAnotherRestrictionComponent(t);
                var intersectionType = this.intersect(this.type, pi.type);
                try {
                    var is = intersectionType.checkConfluent();
                    if (!is.isOk()) {
                        var rc = is;
                        return rc.toRestriction();
                    }
                    return new PropertyIs(this.name, intersectionType);
                }
                finally {
                    this.release(intersectionType);
                }
            }
        }
        return null;
    };
    return PropertyIs;
}(MatchesProperty));
exports.PropertyIs = PropertyIs;
var anotherSource = [];
function anotherRestrictionComponent() {
    return anotherSource.length > 0 ? anotherSource[anotherSource.length - 1] : null;
}
exports.anotherRestrictionComponent = anotherRestrictionComponent;
function setAnotherRestrictionComponent(src) {
    var owner;
    while (src) {
        owner = src.owner();
        if (owner instanceof ts.InheritedType) {
            src = owner.contextMeta();
        }
        else {
            src = null;
        }
    }
    anotherSource.push(owner);
}
function releaseAnotherRestrictionComponent(l) {
    if (l === void 0) { l = 0; }
    while (anotherSource.length > l) {
        anotherSource.pop();
    }
}
exports.releaseAnotherRestrictionComponent = releaseAnotherRestrictionComponent;
function anotherRestrictionComponentsCount() {
    return anotherSource.length;
}
exports.anotherRestrictionComponentsCount = anotherRestrictionComponentsCount;
/**
 * this cosnstraint checks that map property values passes to particular type if exists
 */
var MapPropertyIs = (function (_super) {
    __extends(MapPropertyIs, _super);
    function MapPropertyIs(regexp, type) {
        _super.call(this, type);
        this.regexp = regexp;
        this.type = type;
    }
    MapPropertyIs.prototype.path = function () {
        return "/" + this.regexp + "/";
    };
    MapPropertyIs.prototype.matches = function (s) {
        if (s.match(this.regexp)) {
            return true;
        }
        return false;
    };
    MapPropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    MapPropertyIs.prototype.propId = function () {
        return '[' + this.regexp + ']';
    };
    MapPropertyIs.prototype.facetName = function () {
        return "mapPropertyIs";
    };
    MapPropertyIs.prototype.value = function () {
        return this.type;
    };
    MapPropertyIs.prototype.regexpValue = function () {
        return this.regexp;
    };
    MapPropertyIs.prototype.validateSelf = function (t) {
        var m = this.checkValue();
        if (m) {
            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, m, this);
        }
        return _super.prototype.validateSelf.call(this, t);
    };
    MapPropertyIs.prototype.checkValue = function () {
        try {
            new RegExp(this.regexp);
        }
        catch (e) {
            return e.message;
        }
        return null;
    };
    MapPropertyIs.prototype.composeWith = function (t) {
        if (t instanceof MapPropertyIs) {
            var pi = t;
            if (pi.regexp === this.regexp) {
                if (this.type.typeFamily().indexOf(pi.type) != -1) {
                    return pi;
                }
                if (pi.type.typeFamily().indexOf(this.type) != -1) {
                    return this;
                }
                var intersectionType = this.intersect(this.type, pi.type);
                try {
                    var is = intersectionType.checkConfluent();
                    if (!is.isOk()) {
                        var rc = is;
                        return rc.toRestriction();
                    }
                    return new MapPropertyIs(this.regexp, intersectionType);
                }
                finally {
                    this.release(intersectionType);
                }
            }
        }
        return null;
    };
    MapPropertyIs.prototype.check = function (i, p) {
        if (i) {
            if (typeof i == 'object') {
                var fixedProperties = {};
                if (this._owner != null) {
                    this._owner.meta().filter(function (x) { return x instanceof PropertyIs; }).forEach(function (x) {
                        fixedProperties[x.propertyName()] = true;
                    });
                }
                var rs = new ts.Status(ts.Status.OK, 0, "", this);
                for (var _i = 0, _a = Object.getOwnPropertyNames(i); _i < _a.length; _i++) {
                    var n = _a[_i];
                    if (fixedProperties[n]) {
                        continue;
                    }
                    if (n.match(this.regexp)) {
                        var stat = this.validateProp(i, n, this.type, p);
                        if (!stat.isOk()) {
                            rs.addSubStatus(stat);
                        }
                    }
                }
                return rs;
            }
        }
        return ts.ok();
    };
    return MapPropertyIs;
}(MatchesProperty));
exports.MapPropertyIs = MapPropertyIs;
/**
 * this constraint tests that additional property
 */
var AdditionalPropertyIs = (function (_super) {
    __extends(AdditionalPropertyIs, _super);
    function AdditionalPropertyIs(type) {
        _super.call(this, type);
        this.type = type;
    }
    AdditionalPropertyIs.prototype.path = function () {
        return this.facetName();
    };
    AdditionalPropertyIs.prototype.matches = function (s) {
        return true;
    };
    AdditionalPropertyIs.prototype.requiredType = function () {
        return ts.OBJECT;
    };
    AdditionalPropertyIs.prototype.propId = function () {
        return '[]';
    };
    AdditionalPropertyIs.prototype.facetName = function () {
        return "additionalProperties";
    };
    AdditionalPropertyIs.prototype.value = function () {
        return this.type;
    };
    AdditionalPropertyIs.prototype.match = function (n) {
        var all = this.owner().metaOfType(PropertyIs);
        var map = this.owner().metaOfType(MapPropertyIs);
        for (var i = 0; i < all.length; i++) {
            if (all[i].matches(n)) {
                return true;
            }
        }
        for (var i = 0; i < map.length; i++) {
            if (map[i].matches(n)) {
                return true;
            }
        }
        return false;
    };
    AdditionalPropertyIs.prototype.composeWith = function (t) {
        if (t instanceof AdditionalPropertyIs) {
            var pi = t;
            if (this.type.typeFamily().indexOf(pi.type) != -1) {
                return pi;
            }
            if (pi.type.typeFamily().indexOf(this.type) != -1) {
                return this;
            }
            var intersectionType = this.intersect(this.type, pi.type);
            try {
                var is = intersectionType.checkConfluent();
                if (!is.isOk()) {
                    var rc = is;
                    return rc.toRestriction();
                }
                return new AdditionalPropertyIs(intersectionType);
            }
            finally {
                this.release(intersectionType);
            }
        }
        return null;
    };
    AdditionalPropertyIs.prototype.check = function (i, p) {
        var _this = this;
        var t = this.type;
        var res = new ts.Status(ts.Status.OK, 0, "", this);
        if (i && typeof i === "object") {
            Object.getOwnPropertyNames(i).forEach(function (n) {
                if (!_this.match(n)) {
                    var stat = _this.validateProp(i, n, t, p);
                    if (!stat.isOk()) {
                        res.addSubStatus(stat);
                    }
                }
            });
        }
        return res;
    };
    return AdditionalPropertyIs;
}(MatchesProperty));
exports.AdditionalPropertyIs = AdditionalPropertyIs;
/**
 * common super type for a simple restrictions
 */
var FacetRestriction = (function (_super) {
    __extends(FacetRestriction, _super);
    function FacetRestriction() {
        _super.apply(this, arguments);
    }
    /**
     * Extension of requiredType() method for the case when there are more than a single type
     * hierarchy roots to cover.
     * requiredType() should return the common superclass for the list.
     *
     * @returns {Array} of types or empty list of there is only a single type set by requiredType() method
     */
    FacetRestriction.prototype.requiredTypes = function () {
        return [];
    };
    FacetRestriction.prototype.checkOwner = function (requiredType) {
        var ownerIsCorrect = false;
        if (requiredType.isUnion()) {
            var family = requiredType.typeFamily();
            for (var _i = 0, family_1 = family; _i < family_1.length; _i++) {
                var tp = family_1[_i];
                if (this.owner().isSubTypeOf(tp)) {
                    ownerIsCorrect = true;
                    break;
                }
            }
        }
        else {
            ownerIsCorrect = this.owner().isSubTypeOf(requiredType);
        }
        return ownerIsCorrect;
    };
    FacetRestriction.prototype.validateSelf = function (registry) {
        var _this = this;
        var ownerIsCorrect = false;
        if (this.checkOwner(this.requiredType())) {
            if (this.requiredTypes() && this.requiredTypes().length > 0) {
                var owner = this.owner();
                var correctRequiredSuperType = _.find(this.requiredTypes(), function (requiredType) { return _this.checkOwner(requiredType); });
                if (correctRequiredSuperType) {
                    ownerIsCorrect = true;
                }
            }
            else {
                ownerIsCorrect = true;
            }
        }
        if (!ownerIsCorrect) {
            var typeNames = this.requiredType().name();
            if (this.requiredTypes() && this.requiredTypes().length > 0) {
                typeNames = "[" + this.requiredTypes().map(function (requiredType) { return requiredType.name(); }).join() + "]";
            }
            var rs = ts.error(this.facetName() + " facet can only be used with " + typeNames + " types", this);
            rs.setValidationPath({ name: this.facetName() });
            return rs;
        }
        var m = this.checkValue();
        if (m) {
            var rs = ts.error(m, this, true);
            rs.setValidationPath({ name: this.facetName() });
            return rs;
        }
        return ts.ok();
    };
    return FacetRestriction;
}(ts.Constraint));
exports.FacetRestriction = FacetRestriction;
function is_int(value) {
    if ((parseFloat(value) == parseInt(value)) && !isNaN(value)) {
        return true;
    }
    else {
        return false;
    }
}
/**
 * abstract super type for every min max restriction
 */
var MinMaxRestriction = (function (_super) {
    __extends(MinMaxRestriction, _super);
    function MinMaxRestriction(_facetName, _value, _max, _opposite, _requiredType, _isInt) {
        _super.call(this);
        this._facetName = _facetName;
        this._value = _value;
        this._max = _max;
        this._opposite = _opposite;
        this._requiredType = _requiredType;
        this._isInt = _isInt;
    }
    MinMaxRestriction.prototype.facetName = function () {
        return this._facetName;
    };
    MinMaxRestriction.prototype.isIntConstraint = function () {
        return this._isInt;
    };
    MinMaxRestriction.prototype.isMax = function () {
        return this._max;
    };
    MinMaxRestriction.prototype.value = function () {
        return this._value;
    };
    MinMaxRestriction.prototype.check = function (i) {
        var o = this.extractValue(i);
        if (typeof o == 'number') {
            if (this.isMax()) {
                if (this.value() < o) {
                    return this.createError();
                }
            }
            else {
                if (this.value() > o) {
                    return this.createError();
                }
            }
        }
        return ts.ok();
    };
    MinMaxRestriction.prototype.createError = function () {
        return ts.error(this.toString(), this);
    };
    MinMaxRestriction.prototype.minValue = function () {
        if (this._isInt) {
            return 0;
        }
        return Number.NEGATIVE_INFINITY;
    };
    MinMaxRestriction.prototype.requiredType = function () {
        return this._requiredType;
    };
    MinMaxRestriction.prototype.checkValue = function () {
        if (typeof this._value != "number") {
            return "'" + this.facetName() + "' value should be a number";
        }
        if (this.isIntConstraint()) {
            if (!is_int(this.value())) {
                return "'" + this.facetName() + "' value should be an integer";
            }
        }
        if (this.value() < this.minValue()) {
            return this.facetName() + "' value should be at least " + this.minValue();
        }
    };
    MinMaxRestriction.prototype.composeWith = function (t) {
        if (t instanceof MinMaxRestriction) {
            var mx = t;
            if (mx.facetName() == this.facetName()) {
                if (mx.isMax() == this.isMax()) {
                    if (this.isMax()) {
                        if (this.value() < mx.value()) {
                            return mx;
                        }
                        else {
                            return this;
                        }
                    }
                    else {
                        if (this.value() > mx.value()) {
                            return mx;
                        }
                        else {
                            return this;
                        }
                    }
                }
            }
            if (mx.facetName() === this._opposite) {
                if (this.isMax()) {
                    if (mx.value() > this.value()) {
                        return this.nothing(t);
                    }
                }
                else {
                    if (mx.value() < this.value()) {
                        return this.nothing(t);
                    }
                }
            }
        }
        return null;
    };
    MinMaxRestriction.prototype.facetPath = function () {
        var arr = [this.facetName()];
        var owner = this._owner;
        if (owner != null) {
            if (owner instanceof ts.InheritedType) {
                var it = owner;
                arr = ts.typePath(it).concat(arr);
            }
        }
        return arr.join(".");
    };
    MinMaxRestriction.prototype.toString = function () {
        return "'" + this.facetPath() + "=" + this.value() + "' i.e. " + this.textMessagePart() + " " + this.value();
    };
    MinMaxRestriction.prototype.conflictMessage = function (otherPath, otherValue) {
        var arr = this.isMax() ? ["less", "higher"] : ["higher", "less"];
        return "['" + this.facetPath() + "=" + this.value() + "' is " + arr[0] + " than '" + otherPath + "=" + otherValue + "'. The " + this._opposite + " cannot be " + arr[1] + " than the " + this.facetName() + ".]";
    };
    return MinMaxRestriction;
}(FacetRestriction));
exports.MinMaxRestriction = MinMaxRestriction;
var MultipleOf = (function (_super) {
    __extends(MultipleOf, _super);
    function MultipleOf(_value) {
        _super.call(this);
        this._value = _value;
    }
    MultipleOf.prototype.value = function () {
        return this._value;
    };
    MultipleOf.prototype.check = function (o) {
        if (typeof o == 'number') {
            var q = o / this.value();
            if (!is_int(q)) {
                return new ts.Status(ts.Status.ERROR, 0, "result of division of " + o + " on " + this.value() + " should be integer", this);
            }
        }
        return ts.ok();
    };
    MultipleOf.prototype.composeWith = function (t) {
        return null;
    };
    MultipleOf.prototype.facetName = function () {
        return "multipleOf";
    };
    MultipleOf.prototype.checkValue = function () {
        if (typeof this._value != "number") {
            return "'" + this.facetName() + "' value should be a number";
        }
        return null;
    };
    MultipleOf.prototype.requiredType = function () {
        return ts.NUMBER;
    };
    return MultipleOf;
}(FacetRestriction));
exports.MultipleOf = MultipleOf;
/**
 * maximum  constraint
 */
var Maximum = (function (_super) {
    __extends(Maximum, _super);
    function Maximum(val) {
        _super.call(this, "maximum", val, true, "minimum", ts.NUMBER, false);
    }
    Maximum.prototype.extractValue = function (i) {
        return i;
    };
    Maximum.prototype.textMessagePart = function () {
        return "value should not be more than";
    };
    return Maximum;
}(MinMaxRestriction));
exports.Maximum = Maximum;
/**
 * minimum constraint
 */
var Minimum = (function (_super) {
    __extends(Minimum, _super);
    function Minimum(val) {
        _super.call(this, "minimum", val, false, "maximum", ts.NUMBER, false);
    }
    Minimum.prototype.extractValue = function (i) {
        return i;
    };
    Minimum.prototype.textMessagePart = function () {
        return "value should not be less than";
    };
    return Minimum;
}(MinMaxRestriction));
exports.Minimum = Minimum;
/**
 * max items cosntraint
 */
var MaxItems = (function (_super) {
    __extends(MaxItems, _super);
    function MaxItems(val) {
        _super.call(this, "maxItems", val, true, "minItems", ts.ARRAY, true);
    }
    MaxItems.prototype.extractValue = function (i) {
        if (Array.isArray(i)) {
            return i.length;
        }
    };
    MaxItems.prototype.textMessagePart = function () {
        return "array items count should not be more than";
    };
    return MaxItems;
}(MinMaxRestriction));
exports.MaxItems = MaxItems;
/**
 * min items cosntraint
 */
var MinItems = (function (_super) {
    __extends(MinItems, _super);
    function MinItems(val) {
        _super.call(this, "minItems", val, false, "maxItems", ts.ARRAY, true);
    }
    MinItems.prototype.extractValue = function (i) {
        if (Array.isArray(i)) {
            return i.length;
        }
    };
    MinItems.prototype.textMessagePart = function () {
        return "array items count should not be less than";
    };
    return MinItems;
}(MinMaxRestriction));
exports.MinItems = MinItems;
/**
 * max length
 */
var MaxLength = (function (_super) {
    __extends(MaxLength, _super);
    function MaxLength(val) {
        _super.call(this, "maxLength", val, true, "minLength", new ts.UnionType("string and file", [ts.STRING, ts.FILE]), true);
    }
    MaxLength.prototype.extractValue = function (i) {
        if (typeof i == 'string') {
            return i.length;
        }
        return 0;
    };
    MaxLength.prototype.textMessagePart = function () {
        return "string length should not be more than";
    };
    return MaxLength;
}(MinMaxRestriction));
exports.MaxLength = MaxLength;
/**
 * min length
 */
var MinLength = (function (_super) {
    __extends(MinLength, _super);
    function MinLength(val) {
        _super.call(this, "minLength", val, false, "maxLength", new ts.UnionType("string and file", [ts.STRING, ts.FILE]), true);
    }
    MinLength.prototype.extractValue = function (i) {
        if (typeof i == 'string') {
            return i.length;
        }
        return 0;
    };
    MinLength.prototype.textMessagePart = function () {
        return "string length should not be less than";
    };
    return MinLength;
}(MinMaxRestriction));
exports.MinLength = MinLength;
/**
 * max properties constraint
 */
var MaxProperties = (function (_super) {
    __extends(MaxProperties, _super);
    function MaxProperties(val) {
        _super.call(this, "maxProperties", val, true, "minProperties", ts.OBJECT, true);
    }
    MaxProperties.prototype.extractValue = function (i) {
        return Object.keys(i).length;
    };
    MaxProperties.prototype.textMessagePart = function () {
        return "object properties count should not be more than";
    };
    return MaxProperties;
}(MinMaxRestriction));
exports.MaxProperties = MaxProperties;
/**
 * min properties constraint
 */
var MinProperties = (function (_super) {
    __extends(MinProperties, _super);
    function MinProperties(val) {
        _super.call(this, "minProperties", val, false, "maxProperties", ts.OBJECT, true);
    }
    MinProperties.prototype.extractValue = function (i) {
        return Object.keys(i).length;
    };
    MinProperties.prototype.textMessagePart = function () {
        return "object properties count should not be less than";
    };
    return MinProperties;
}(MinMaxRestriction));
exports.MinProperties = MinProperties;
/**
 * unique items constraint
 */
var UniqueItems = (function (_super) {
    __extends(UniqueItems, _super);
    function UniqueItems(_value) {
        _super.call(this);
        this._value = _value;
    }
    UniqueItems.prototype.facetName = function () { return "uniqueItems"; };
    UniqueItems.prototype.requiredType = function () { return ts.ARRAY; };
    UniqueItems.prototype.check = function (i) {
        if (!this._value) {
            return ts.ok();
        }
        if (Array.isArray(i)) {
            var r = i;
            if (_.unique(r).length != r.length) {
                return ts.error(this.toString(), this);
            }
        }
        return ts.ok();
    };
    UniqueItems.prototype.composeWith = function (r) {
        if (r instanceof UniqueItems) {
            var mm = r;
            if (mm._value == this._value) {
                return this;
            }
        }
        return null;
    };
    UniqueItems.prototype.value = function () {
        return this._value;
    };
    UniqueItems.prototype.checkValue = function () {
        return null;
    };
    UniqueItems.prototype.toString = function () {
        return "items should be unique";
    };
    return UniqueItems;
}(FacetRestriction));
exports.UniqueItems = UniqueItems;
/**
 * components of array should be of type
 */
var ComponentShouldBeOfType = (function (_super) {
    __extends(ComponentShouldBeOfType, _super);
    function ComponentShouldBeOfType(type) {
        _super.call(this);
        this.type = type;
    }
    ComponentShouldBeOfType.prototype.facetName = function () { return "items"; };
    ComponentShouldBeOfType.prototype.requiredType = function () { return ts.ARRAY; };
    ComponentShouldBeOfType.prototype.toString = function () {
        return "items should be of type " + this.type;
    };
    ComponentShouldBeOfType.prototype.check = function (i) {
        var rs = new ts.Status(ts.Status.OK, 0, "", this);
        if (Array.isArray(i)) {
            var ar = i;
            for (var j = 0; j < ar.length; j++) {
                var ss = this.type.validate(ar[j], false, false);
                if (!ss.isOk()) {
                    var t = this.type;
                    if (t.isUnknown() || t.isRecurrent()) {
                        var s = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Array instance is validated against unknown type: '" + t.name() + "'", this);
                        return s;
                    }
                }
                ss.setValidationPath({ name: "" + j });
                rs.addSubStatus(ss);
            }
        }
        return rs;
    };
    ComponentShouldBeOfType.prototype.validateSelf = function (registry) {
        if (this.type.isAnonymous()) {
            var st = this.type.validateType(registry);
            if (!st.isOk()) {
                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Component type has error: " + st.getMessage(), this);
            }
            return st;
        }
        if (this.type.isExternal()) {
            var p = new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "It is not allowed to use external types in component type definitions", this);
            return p;
        }
        if (this.type.isSubTypeOf(ts.UNKNOWN) || this.type.isSubTypeOf(ts.RECURRENT)) {
            return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Component refers to unknown type '" + this.type.name() + "'", this);
        }
        if (this.type.isUnion()) {
            var ui = _.find(this.type.typeFamily(), function (x) { return x.isSubTypeOf(ts.UNKNOWN); });
            if (ui) {
                return new typesystem_2.Status(typesystem_2.Status.ERROR, 0, "Component refers to unknown type '" + ui.name() + "'", this);
            }
        }
        return ts.ok();
    };
    ComponentShouldBeOfType.prototype.composeWith = function (t) {
        if (t instanceof ComponentShouldBeOfType) {
            var pi = t;
            if (this.type.typeFamily().indexOf(pi.type) != -1) {
                return pi;
            }
            if (pi.type.typeFamily().indexOf(this.type) != -1) {
                return this;
            }
            var intersectionType = this.intersect(this.type, pi.type);
            try {
                var is = intersectionType.checkConfluent();
                if (!is.isOk()) {
                    var rc = is;
                    return rc.toRestriction();
                }
                return new ComponentShouldBeOfType(intersectionType);
            }
            finally {
                this.release(intersectionType);
            }
        }
        return null;
    };
    ComponentShouldBeOfType.prototype.checkValue = function () {
        return null;
    };
    ComponentShouldBeOfType.prototype.value = function () {
        return this.type;
    };
    return ComponentShouldBeOfType;
}(FacetRestriction));
exports.ComponentShouldBeOfType = ComponentShouldBeOfType;
/**
 * regular expression (pattern) constraint
 */
var Pattern = (function (_super) {
    __extends(Pattern, _super);
    function Pattern(_value) {
        _super.call(this);
        this._value = _value;
    }
    Pattern.prototype.facetName = function () { return "pattern"; };
    Pattern.prototype.requiredType = function () { return ts.STRING; };
    Pattern.prototype.check = function (i) {
        if (typeof i == 'string') {
            var st = i;
            try {
                var matches = st.match(this._value);
                var gotMatch = false;
                if (matches) {
                    for (var _i = 0, matches_1 = matches; _i < matches_1.length; _i++) {
                        var m = matches_1[_i];
                        if (m.length == st.length) {
                            gotMatch = true;
                            break;
                        }
                    }
                }
                if (!gotMatch) {
                    return new ts.Status(ts.Status.ERROR, 0, "String should match to '" + this.value() + "'", this);
                }
            }
            catch (e) {
            }
        }
        return ts.ok();
    };
    Pattern.prototype.composeWith = function (r) {
        if (r instanceof Pattern) {
            var v = r;
            if (v._value === this._value) {
                return this;
            }
            return this.nothing(r, "pattern restrictions can not be composed at one type");
        }
        return null;
    };
    Pattern.prototype.value = function () {
        return this._value;
    };
    Pattern.prototype.checkValue = function () {
        try {
            new RegExp(this._value);
        }
        catch (e) {
            return e.message;
        }
        return null;
    };
    Pattern.prototype.toString = function () {
        return "should pass reg exp:" + this.value;
    };
    return Pattern;
}(FacetRestriction));
exports.Pattern = Pattern;
/**
 * regular expression (pattern) constraint
 */
var Format = (function (_super) {
    __extends(Format, _super);
    function Format(_value) {
        _super.call(this);
        this._value = _value;
    }
    Format.prototype.facetName = function () { return "format"; };
    Format.prototype.requiredType = function () {
        return ts.SCALAR;
    };
    Format.prototype.requiredTypes = function () {
        return [ts.NUMBER, ts.INTEGER, ts.DATETIME];
    };
    Format.prototype.check = function (i) {
        return ts.ok();
    };
    Format.prototype.composeWith = function (r) {
        if (r instanceof Format) {
            var v = r;
            if (v._value === this._value) {
                return this;
            }
            return this.nothing(r, "Format restrictions can not be composed at one type");
        }
        return null;
    };
    Format.prototype.value = function () {
        return this._value;
    };
    Format.prototype.checkValue = function () {
        var _this = this;
        try {
            var allowedValues = [];
            if (this.owner().isSubTypeOf(ts.INTEGER)) {
                allowedValues = ["int32", "int64", "int", "int16", "int8"];
            }
            else if (this.owner().isSubTypeOf(ts.NUMBER)) {
                allowedValues = ["int32", "int64", "int", "long", "float", "double", "int16", "int8"];
            }
            else if (this.owner().isSubTypeOf(ts.DATETIME)) {
                allowedValues = ["rfc3339", "rfc2616"];
            }
            else
                return null;
            var found = _.find(allowedValues, function (allowedValue) { return allowedValue == _this.value(); });
            if (!found) {
                return "Following format values are allowed: " + allowedValues.map(function (x) { return ("'" + x + "'"); }).join(", ");
            }
        }
        catch (e) {
            return e.message;
        }
        return null;
    };
    Format.prototype.toString = function () {
        return "should have format:" + this.value;
    };
    return Format;
}(FacetRestriction));
exports.Format = Format;
/**
 * enum constraint
 */
var Enum = (function (_super) {
    __extends(Enum, _super);
    function Enum(_value) {
        _super.call(this);
        this._value = _value;
    }
    Enum.prototype.facetName = function () { return "enum"; };
    Enum.prototype.requiredType = function () { return ts.SCALAR; };
    Enum.prototype.check = function (i) {
        if (!this.checkStatus) {
            var opts = this.value();
            if (!Array.isArray(opts)) {
                opts = [opts];
            }
            if (!opts.some(function (x) { return x == i; })) {
                return ts.error(this.toString(), this);
            }
        }
        return ts.ok();
    };
    Enum.prototype.composeWith = function (r) {
        if (r instanceof Enum) {
            var v = r;
            var sss = _.intersection(this._value, v._value);
            if (sss.length == 0) {
                return this.nothing(r);
            }
            return new Enum(sss);
        }
        return null;
    };
    Enum.prototype.value = function () {
        return this._value;
    };
    Enum.prototype.checkValue = function () {
        var _this = this;
        if (!this.owner().isSubTypeOf(this.requiredType())) {
            return "'enum' facet can only be used with: " + this.requiredType().name();
        }
        if (this.requiredTypes() && this.requiredTypes().length > 0) {
            var owner = this.owner();
            var requiredSuperType = _.find(this.requiredTypes(), function (requiredType) { return owner.isSubTypeOf(requiredType); });
            if (!requiredSuperType) {
                var typeNames = "[" + this.requiredTypes().map(function (requiredType) { return ("'" + requiredType.name() + "'"); }).join(", ") + "]";
                return "'enum' facet can only be used with: " + typeNames;
            }
        }
        if (!Array.isArray(this._value)) {
            return "'enum' facet value must be defined by array";
        }
        // if (_.uniq(this._value).length<this._value.length){
        //     return "enum facet can only contain unique items";
        // }
        var result = null;
        this.checkStatus = true;
        try {
            this._value.forEach(function (x) {
                var res = _this.owner().validate(x);
                if (!res.isOk()) {
                    result = res.getMessage();
                }
            });
        }
        finally {
            this.checkStatus = false;
        }
        return result;
    };
    Enum.prototype.toString = function () {
        var valStr = Array.isArray(this._value) ? this._value.map(function (x) { return ("'" + x + "'"); }).join(", ") : "'" + this._value + "'";
        return "value should be one of: " + valStr;
    };
    return Enum;
}(FacetRestriction));
exports.Enum = Enum;
/**
 * this function attempts to optimize to set of restrictions
 * @param r
 * @returns {ts.Constraint[]}
 */
function optimize(r) {
    r = r.map(function (x) { return x.preoptimize(); });
    var optimized = [];
    r.forEach(function (x) {
        if (x instanceof typesystem_1.AndRestriction) {
            var ar = x;
            ar.options().forEach(function (y) { optimized.push(y); });
        }
        else {
            optimized.push(x);
        }
    });
    var transformed = true;
    while (transformed) {
        transformed = false;
        for (var i = 0; i < optimized.length; i++) {
            for (var j = 0; j < optimized.length; j++) {
                var rs0 = optimized[i];
                var rs1 = optimized[j];
                if (rs0 !== rs1) {
                    var compose = rs0.tryCompose(rs1);
                    if (compose) {
                        var newOptimized = optimized.filter(function (x) { return x !== rs0 && x !== rs1; });
                        newOptimized.push(compose);
                        transformed = true;
                        optimized = newOptimized;
                        break;
                    }
                }
            }
            if (transformed) {
                break;
            }
        }
    }
    return optimized;
}
exports.optimize = optimize;
function actualUnknownType(t) {
    if (!t.isSubTypeOf(ts.UNKNOWN)) {
        return null;
    }
    if (t.name() != null) {
        return t;
    }
    for (var _i = 0, _a = t.superTypes(); _i < _a.length; _i++) {
        var st = _a[_i];
        var ust = actualUnknownType(st);
        if (ust != null) {
            return ust;
        }
    }
    return t;
}
//# sourceMappingURL=restrictions.js.map